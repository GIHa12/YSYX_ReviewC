
# 调试输出、DGB、Valgrind
## 调试输出的优势：
- 你可以使用变量的调试输出，来看到程序执行的整个轨迹，它让你跟踪变量是如何产生错误的。使用gdb的话，你必须为每个变量放置查看和调试语句，并且难以获得执行的实际轨迹。
- 调试输出存在于代码中，当你需要它们是你可以重新编译使它们回来。使用gdb的话，你每次调试都需要重新配置相同的信息。
- 当服务器工作不正常时，它的调试日志功能易于打开，并且在它运行中可以监视日志来查看哪里不对。系统管理员知道如何处理日志，他们不知道如何使用gdb。
打印信息更加容易。调试器通常由于它奇特的UI和前后矛盾显得难用且古怪。debug("Yo, dis right? %d", my_stuff);就没有那么麻烦。
- 编写调试输出来发现缺陷，强迫你实际分析代码，并且使用科学方法。你可以认为它是，“我假设这里的代码是错误的”，你可以运行它来验证你的假设，如果这里没有错误那么你可以移动到其它地方。这看起来需要更长时间，但是实际上更快，因为你经历了“鉴别诊断”的过程，并排除所有可能的原因，直到你找到它。
- 调试输入更适于和单元测试一起运行。你可以实际上总是编译调试语句，单元测试时可以随时查看日志。如果你用gdb，你需要在gdb中重复运行单元测试，并跟踪他来查看发生了什么。
- 使用Valgrind可以得到和调试输出等价的内存相关的错误，所以你并不需要使用类似gdb的东西来寻找缺陷。

## 综合调试策略
- Valgrind用于捕获所有内存错误。如果Valgrind中含有错误或Valgrind会严重拖慢程序，我会使用gdb。
- 调试输出用于诊断或修复有关逻辑或使用上的缺陷。在你使用Valgrind之前，这些共计90%的缺陷。
- 使用gdb解决剩下的“谜之bug”，或如要收集信息的紧急情况。如果Valgrind不起作用，并且我不能打印出所需信息，我就会使用gdb开始四处搜索。这里我仅仅使用gdb来收集信息。一旦我弄清发生了什么，我会回来编程单元测试来引发缺陷，之后编程打印语句来查找原因。

## 综合调试步骤
1. 创建一个小型文本文件叫做notes.txt，并且将它用作记录想法、bug和问题的“实验记录”。
2. 在你使用gdb之前，写下你打算修复的bug，以及可能的产生原因。
3. 对于每个原因，写下你所认为的，问题来源的函数或文件，或者仅仅写下你不知道。
4. 现在启动gdb并且使用file:function挑选最可能的因素，之后在那里设置断点。
5. 使用gdb运行程序，并且确认它是否是真正原因。查明它的最好方式就是看看你是否可以使用set命令，简单修复问题或者重现错误。
6. 如果它不是真正原因，则在notes.txt中标记它不是，以及理由。移到下一个可能的原因，并且使最易于调试的，之后记录你收集到的信息。

## GBD调试
1. 获取当前进程？
```bash
$ ps ax | grep ex31
10026 s000  S+     0:00.11 ./ex31
10036 s001  R+     0:00.00 grep ex31
```
2. 在gdb提示符下，使用attach命令附加到目标进程。假设目标进程的进程ID是12345，那么命令如下：
```bash
gdb attach -p <进程ID>
```
或者直接：
```bash
gdb <可执行文件名> <进程ID>
```
3. 添加断点
```bash
break <行号>
break 文件名:<行号>/<函数名>
```
4. 查看程序源码和行号？：`list`
5. 开始运行程序:`r`
6. 跳过断点，继续运行：`cont` ? `next`







